using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ServiceGenerator;

[Generator]
public class EntityFactoryGenerator : IIncrementalGenerator {
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        // Filter structs annotated with the [EntityFactory] attribute. Only filtered Syntax Nodes can trigger code generation.
        IncrementalValuesProvider<((StructDeclarationSyntax,  List<string> componentTypes, List<UsingDirectiveSyntax> usings), bool reportAttributeFound)> provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is StructDeclarationSyntax,
                (ctx, _) => GetStructDeclarationForSourceGen(ctx))
            .Where(t => t.reportAttributeFound)
            .Select((t, _) => t);

        // Generate the source code.
        context.RegisterSourceOutput(provider, GenerateCode);
    }

    private static ((StructDeclarationSyntax, List<string> componentTypes, List<UsingDirectiveSyntax> usings), bool reportAttributeFound) GetStructDeclarationForSourceGen(GeneratorSyntaxContext context)
    {
        StructDeclarationSyntax structDeclarationSyntax = (StructDeclarationSyntax)context.Node;
        List<string> componentTypes = new();
        List<UsingDirectiveSyntax> usings = new();

        // Extract using directives
        CompilationUnitSyntax root = (CompilationUnitSyntax)structDeclarationSyntax.SyntaxTree.GetRoot();
        usings.AddRange(root.Usings);

        foreach (AttributeSyntax attributeSyntax in structDeclarationSyntax.AttributeLists.SelectMany(attributeListSyntax => attributeListSyntax.Attributes))
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol) continue;

            string attributeName = attributeSymbol.ContainingType.ToDisplayString();

            if (attributeName != "Commons.Architectures.EntityFactory") continue;

            // Check for GenWith attribute and extract component types
            foreach (AttributeSyntax attr in structDeclarationSyntax.AttributeLists.SelectMany(al => al.Attributes))
            {
                if (context.SemanticModel.GetSymbolInfo(attr).Symbol is not IMethodSymbol attrSymbol) continue;

                string attrName = attrSymbol.ContainingType.ToDisplayString();

                if (attrName != "Commons.Architectures.GenWith") continue;

                SeparatedSyntaxList<AttributeArgumentSyntax> args = attr.ArgumentList!.Arguments;
                componentTypes.AddRange(args.Select(arg => arg.Expression).OfType<TypeOfExpressionSyntax>().Select(typeOfExpr => typeOfExpr.Type).Select(type => type.ToString()));
            }

            return ((structDeclarationSyntax, componentTypes, usings), true);
        }

        return ((structDeclarationSyntax, componentTypes, usings), false);
    }

    public static void GenerateCode(SourceProductionContext context, ((StructDeclarationSyntax structDeclaration, List<string> componentTypes, List<UsingDirectiveSyntax> usings) data, bool _) input){
        StructDeclarationSyntax structDeclarationSyntax = input.data.structDeclaration;
        List<string> componentTypes = input.data.componentTypes;
        List<UsingDirectiveSyntax> usings = input.data.usings;

        string factoryName = structDeclarationSyntax.Identifier.Text;
        NamespaceDeclarationSyntax namespaceDeclaration = structDeclarationSyntax.Parent as NamespaceDeclarationSyntax;
        string namespaceName = namespaceDeclaration?.Name.ToString() ?? "UnknownNamespace";
        
        // Go through all filtered class declarations.
        MemoryStream sourceStream = new();
        StreamWriter sourceStreamWriter = new(sourceStream, Encoding.UTF8);
        IndentedTextWriter codeWriter = new(sourceStreamWriter);
        
        codeWriter.WriteLine("// <auto-generated/>");
        codeWriter.WriteLine("using System;");
        codeWriter.WriteLine("using Unity.Collections;");
        codeWriter.WriteLine("using Unity.Entities;");
        codeWriter.WriteLine("using Unity.Burst;");
        codeWriter.WriteLine($"using {namespaceName};");
        
        foreach (UsingDirectiveSyntax usingDirective in usings)
        {
            codeWriter.WriteLine(usingDirective.ToString());
        }
        
        codeWriter.WriteLine($"namespace {namespaceName} {{");
        // open namespace
        codeWriter.Indent++;
        codeWriter.WriteLine($"public partial struct {factoryName} : IDisposable {{");
        // open struct
        codeWriter.Indent++;
        codeWriter.WriteLine("public EntityArchetype Archetype;");
        codeWriter.WriteLine("public EntityQuery Query;");
        codeWriter.WriteLine($"public {factoryName} Setup(ref SystemState state) {{");
        // open Setup
        codeWriter.Indent++;
        codeWriter.WriteLine("NativeList<ComponentType> componentTypes = new(Allocator.Temp) {");
        // open NativeList
        codeWriter.Indent++;

        foreach (string component in componentTypes) {
            codeWriter.WriteLine($"ComponentType.ReadWrite<{component}>(),");
        }

        // close NativeList
        codeWriter.Indent--;
        codeWriter.WriteLine("};");

        codeWriter.WriteLine("");
        codeWriter.WriteLine("// Caching the Archetype ");
        codeWriter.WriteLine("Archetype = state.EntityManager.CreateArchetype(componentTypes.AsArray()); ");
        codeWriter.WriteLine("// Caching the Query matching the archetype ");
        codeWriter.WriteLine("Query = new EntityQueryBuilder(Allocator.Temp).WithAll(ref componentTypes).Build(ref state);");
        codeWriter.WriteLine("");
        codeWriter.WriteLine("componentTypes.Dispose();");
        codeWriter.WriteLine("return this;");

        // close Setup
        codeWriter.Indent--;
        codeWriter.WriteLine("}");
        codeWriter.WriteLine("// Use this method to instantiate something with the same archetype");
        codeWriter.WriteLine("public Entity CreateEntity(ref SystemState state) => state.EntityManager.CreateEntity(Archetype); ");
        codeWriter.WriteLine("");
        codeWriter.WriteLine("public void Dispose() {");

        // open function
        codeWriter.Indent++;
        codeWriter.WriteLine("Query.Dispose();");

        // close function
        codeWriter.Indent--;
        codeWriter.WriteLine("}");

        // close struct
        codeWriter.Indent--;
        codeWriter.WriteLine("}");

        // close namespace
        codeWriter.Indent--;
        codeWriter.WriteLine("}");

        sourceStreamWriter.Flush();

        context.AddSource($"{factoryName}.g.cs", SourceText.From(sourceStream, Encoding.UTF8, canBeEmbedded: true));
    }
}