using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace FactoryInitialisation;

[Generator]
public class EntityFactoryInitGenerator : IIncrementalGenerator {
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        // Create a provider to filter structs annotated with the [EntityFactory] attribute
        IncrementalValuesProvider<((StructDeclarationSyntax, List<string> componentTypes), bool reportAttributeFound)> provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is StructDeclarationSyntax,
                (ctx, _) => GetStructDeclarationForSourceGen(ctx))
            .Where(t => t.reportAttributeFound)
            .Select((t, _) => t);
        
        // Register the source code generation for all collected structs
        context.RegisterSourceOutput(provider, GenerateCode);
    }

    private static ((StructDeclarationSyntax, List<string> factoryNames), bool reportAttributeFound) GetStructDeclarationForSourceGen(GeneratorSyntaxContext context) {
        // Cast the node to StructDeclarationSyntax
        var structDeclarationSyntax = (StructDeclarationSyntax)context.Node;
        List<string> factoryNames = new();

        // Iterate over attributes in the struct
        foreach (var attributeSyntax in structDeclarationSyntax.AttributeLists.SelectMany(attributeList => attributeList.Attributes)) {
            // Get the symbol information for the attribute
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol) continue;

            // Check if the attribute is [EntityFactory]
            if (attributeSymbol.ContainingType.ToDisplayString() == "Commons.Architectures.EntityFactory") {
                // Add the factory name
                factoryNames.Add(structDeclarationSyntax.Identifier.Text);
                return ((structDeclarationSyntax, factoryNames), true);
            }
        }

        // Return the struct and indicate the attribute was not found
        return ((structDeclarationSyntax, factoryNames), false);
    }

    public static void GenerateCode(SourceProductionContext context, ((StructDeclarationSyntax structDeclaration, List<string> factoryNames) data, bool _) input) {

        var factoryNames = input.data.factoryNames;
      
        // Go through all filtered class declarations.
        MemoryStream sourceStream = new();
        StreamWriter sourceStreamWriter = new(sourceStream, Encoding.UTF8);
        IndentedTextWriter codeWriter = new(sourceStreamWriter);

        codeWriter.WriteLine("// <auto-generated/>");
        codeWriter.WriteLine("using Unity.Entities;");

        codeWriter.WriteLine("namespace Commons.Architectures {");
        codeWriter.Indent++;

        codeWriter.WriteLine("[UpdateInGroup(typeof(Unity.Entities.InitializationSystemGroup))]");
        // open namespace

        codeWriter.WriteLine("public partial struct EntitiesFactoryInitializationSystem : ISystem {");
        // open struct
        codeWriter.Indent++;
        codeWriter.WriteLine("public void OnCreate(ref SystemState state) {");
        codeWriter.Indent++;

        foreach (var factoryName in factoryNames) {
            codeWriter.WriteLine($"EntityFactories.{factoryName}Setup(ref state);");
        }

        codeWriter.WriteLine("state.Enabled = false;");

        codeWriter.Indent--;
        codeWriter.WriteLine("}");
        codeWriter.Indent--;
        codeWriter.WriteLine("}");
        codeWriter.Indent--;
        codeWriter.WriteLine("}");
        
        sourceStreamWriter.Flush();

        context.AddSource($"EntitiesFactoryInitSystem.g.cs", SourceText.From(sourceStream, Encoding.UTF8, canBeEmbedded: true));
    }
}