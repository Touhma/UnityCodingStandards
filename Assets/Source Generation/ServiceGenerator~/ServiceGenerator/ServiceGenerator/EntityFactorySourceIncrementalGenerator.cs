using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ServiceGenerator;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class EntityFactorySourceIncrementalGenerator : IIncrementalGenerator {
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        // Filter structs annotated with the [EntityFactory] attribute. Only filtered Syntax Nodes can trigger code generation.
        IncrementalValuesProvider<((StructDeclarationSyntax, List<string> componentTypes), bool reportAttributeFound)> provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is StructDeclarationSyntax,
                (ctx, _) => GetStructDeclarationForSourceGen(ctx))
            .Where(t => t.reportAttributeFound)
            .Select((t, _) => t);

        // Generate the source code.
        context.RegisterSourceOutput(provider, GenerateCode);
    }

    private static ((StructDeclarationSyntax, List<string> componentTypes), bool reportAttributeFound) GetStructDeclarationForSourceGen(GeneratorSyntaxContext context) {
        StructDeclarationSyntax structDeclarationSyntax = (StructDeclarationSyntax)context.Node;
        List<string> componentTypes = new();

        foreach (AttributeSyntax attributeSyntax in structDeclarationSyntax.AttributeLists.SelectMany(attributeListSyntax => attributeListSyntax.Attributes)) {
            if (ModelExtensions.GetSymbolInfo(context.SemanticModel, attributeSyntax).Symbol is not IMethodSymbol attributeSymbol) continue;

            string attributeName = attributeSymbol.ContainingType.ToDisplayString();

            if (attributeName != "Commons.Architectures.EntityFactory") continue;
            // Check for GenWith attribute and extract component types
            foreach (AttributeSyntax attr in structDeclarationSyntax.AttributeLists.SelectMany(al => al.Attributes)) {
                if (context.SemanticModel.GetSymbolInfo(attr).Symbol is not IMethodSymbol attrSymbol) continue;

                string attrName = attrSymbol.ContainingType.ToDisplayString();

                if (attrName != "Commons.Architectures.GenWith") continue;

                SeparatedSyntaxList<AttributeArgumentSyntax> args = attr.ArgumentList!.Arguments;
                componentTypes.AddRange(args.Select(arg => arg.Expression).OfType<TypeOfExpressionSyntax>().Select(typeOfExpr => typeOfExpr.Type).Select(type => type.ToString()));
            }

            return ((structDeclarationSyntax, componentTypes), true);
        }

        return ((structDeclarationSyntax, componentTypes), false);
    }

    public static void GenerateCode(SourceProductionContext context, ((StructDeclarationSyntax structDeclaration, List<string> componentTypes) data, bool _) input) {
        StructDeclarationSyntax structDeclarationSyntax = input.data.structDeclaration;
        List<string> componentTypes = input.data.componentTypes;

        string factoryName = structDeclarationSyntax.Identifier.Text;
        NamespaceDeclarationSyntax namespaceDeclaration = structDeclarationSyntax.Parent as NamespaceDeclarationSyntax;
        string namespaceName = namespaceDeclaration?.Name.ToString() ?? "UnknownNamespace";

        // Go through all filtered class declarations.
        MemoryStream sourceStream = new();
        StreamWriter sourceStreamWriter = new(sourceStream, Encoding.UTF8);
        IndentedTextWriter codeWriter = new(sourceStreamWriter);
        codeWriter.WriteLine("// <auto-generated/>");
        codeWriter.WriteLine("using System;");
        codeWriter.WriteLine("using Players.Components;");
        codeWriter.WriteLine("using Players.Factories;");
        codeWriter.WriteLine("using Unity.Collections;");
        codeWriter.WriteLine("using Unity.Entities;");
        codeWriter.WriteLine("using Unity.Burst;");
        codeWriter.WriteLine($"namespace {namespaceName} {{");
        // open namespace
        codeWriter.Indent++;
        codeWriter.WriteLine($"public partial struct {factoryName} : IDisposable {{");
        // open struct
        codeWriter.Indent++;
        codeWriter.WriteLine("public EntityArchetype Archetype;");
        codeWriter.WriteLine("public EntityQuery Query;");
        codeWriter.WriteLine("public PlayerEntityFactory Setup(ref SystemState state) {");
        // open Setup
        codeWriter.Indent++;
        codeWriter.WriteLine("NativeList<ComponentType> componentTypes = new(Allocator.Temp) {");
        // open NativeList
        codeWriter.Indent++;

        foreach (string component in componentTypes) {
            codeWriter.WriteLine($"ComponentType.ReadWrite<{component}>(),");
        }

        // close NativeList
        codeWriter.Indent--;
        codeWriter.WriteLine("};");

        codeWriter.WriteLine("");
        codeWriter.WriteLine("// Caching the Archetype ");
        codeWriter.WriteLine("Archetype = state.EntityManager.CreateArchetype(componentTypes.AsArray()); ");
        codeWriter.WriteLine("// Caching the Query matching the archetype ");
        codeWriter.WriteLine("Query = new EntityQueryBuilder(Allocator.Temp).WithAll(ref componentTypes).Build(ref state);");
        codeWriter.WriteLine("");
        codeWriter.WriteLine("componentTypes.Dispose();");
        codeWriter.WriteLine("return this;");

        // close Setup
        codeWriter.Indent--;
        codeWriter.WriteLine("}");
        codeWriter.WriteLine("// Use this method to instantiate something with the same archetype");
        codeWriter.WriteLine("public Entity CreateEntity(ref SystemState state) => state.EntityManager.CreateEntity(Archetype); ");
        codeWriter.WriteLine("");
        codeWriter.WriteLine("public void Dispose() {");

        // open function
        codeWriter.Indent++;
        codeWriter.WriteLine("Query.Dispose();");

        // close function
        codeWriter.Indent--;
        codeWriter.WriteLine("}");

        // close struct
        codeWriter.Indent--;
        codeWriter.WriteLine("}");

        // close namespace
        codeWriter.Indent--;
        codeWriter.WriteLine("}");

        // Add partial code 
        codeWriter.WriteLine("namespace Commons.Architectures {");
        codeWriter.WriteLine("// namespace necessary for the partial to take effect");
        // open namespace
        codeWriter.Indent++;
        codeWriter.WriteLine("public static partial class EntityFactoriesStatics {");
        // open class
        codeWriter.Indent++;
        codeWriter.WriteLine($"public static readonly SharedStatic<{factoryName}> {factoryName} = SharedStatic<{factoryName}>.GetOrCreate<{factoryName}, StaticFieldKey>();");
        // close class
        codeWriter.Indent--;
        codeWriter.WriteLine("}");

        codeWriter.WriteLine("public static partial class EntityFactories {");
        // open static
        codeWriter.Indent++;
        codeWriter.WriteLine("// Call this to access data in the factory ");
        codeWriter.WriteLine($"public static ref {factoryName} {factoryName} => ref EntityFactoriesStatics.{factoryName}.Data;");
        codeWriter.WriteLine("// Call this to setup the factory");
        codeWriter.WriteLine($"public static {factoryName} {factoryName}Setup(ref SystemState state) => EntityFactoriesStatics.{factoryName}.Data = new {factoryName}().Setup(ref state);");
        // close static
        codeWriter.Indent--;
        codeWriter.WriteLine("}");
        // close namespace
        codeWriter.Indent--;
        codeWriter.WriteLine("}");

        sourceStreamWriter.Flush();

        context.AddSource($"{factoryName}.g.cs", SourceText.From(sourceStream, Encoding.UTF8, canBeEmbedded: true));
    }
}